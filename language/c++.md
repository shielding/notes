### c到c++

* 不能通过常引用改变引用对象的值
* const T& 和 const T 不能用来初始化 T& 类型的引用


* 常引用和常指针都不能用于修改值
* new 运算符的返回值是T *
> int \*p = new int[5*20]

> delete []p

* 引用实现的机制？？

* 内联函数：直接把函数体贴到所在位置
> inline int Max(int a, int b) ...

* 函数重载：
    * int Max(double,double)
    * int Max(int,int)
    * int Max(int,int,int)
    * 调用时根据实参的个数和类型判断用哪一个。如果两个都可以用，报错“二义性”
    * 只有返回值类型不同，名字和参数类型及个数相同的不算重载！
    * 重载实现的机制？？

* 缺省
    * 函数最右边的几个参数可以设置缺省值
    * 提高程序的可扩充性：一个函数需要增加参数时，不需要改动之前所有调用该函数的地方，把增加的参数设置上缺省值即可，比如颜色参数默认黑色

* 程序 = 数据结构 + 算法

### 结构化程序设计的缺点：

* 不知道某个函数操作哪些数据结构，也不知道函数调用关系
* 也不利于重用

### 面向对象 —> 类
* 抽象：将数据结构（成员变量）和操作这些数据结构（成员函数）的函数放在一起形成一个**类**
* 可访问范围：
    * private 只有类成员可访问 (缺省) “隐藏”的目的是强制只能通过类的成员函数访问成员变量
    * public
    * protected
* 构造函数 给对象的成员变量赋初值 但对象自己的内存本来就有了，不是构造函数分配的，它只是“装修”。可以有多个，不能有返回值。所有类都有构造函数（没有自己写时默认有无参的构造函数，自己写了就没有）。
* 分配类的数组时，可以 Class\_name[5] = {参数，Class\_name（参数）} 调用有参数的构造函数
* 复制构造函数 只有一个参数，是对同类对象的**引用** 默认就有一个自动的。
    *  除了Class\_name c1(c2) 和 Class\_name c1=c2 会调用复制构造函数以外
    *  当某个函数的参数是一个类对象，传参时它是被复制构造函数赋值的，如果自定义的复制构造函数不是进行拷贝工作，那它与实参就会不一样。
    *  返回值为类的对象时，也是调用复制构造函数把返回值赋给另一个变量（临时变量） dev c++会优化
    *  为了不调用复制构造函数浪费时间，可以让参数的类型为const Class\_name&
* 类型转换构造函数
* 析构函数 对象数组/对象指针数组有几个就会调用几次析构函数 每个对象都有且只有一个析构函数~Class\_name，不负责回收内存 如果new出来的对象没有delete，就不会调用析构函数
* this指针 不能在静态成员函数中使用 普通成员函数相当于隐藏了第一个参数：* this 指向作用于的类对象本身，而静态成员函数没有隐藏的参数

### 静态成员
* 静态成员变量一共只有一份，所有成员共享
* sizeof运算符计算时不会算入静态成员变量
* 静态成员函数并不具体作用于某个对象
* 除了通过对象名、指针、引用.成员名访问，还可以通过类名.成员名访问
* 静态成员本质上是全局的
* 静态成员函数中不能访问非静态成员变量或者调用非静态成员函数
* 注意修改静态成员变量的构造函数是否包含了所有情况，比如复制构造函数是否考虑了？如果情况不全，但析构函数是会在所有对象消亡时都修改静态成员变量的，就会造成变量值出错。

### 封闭类
* 包含成员对象
* 生成封闭类时要注意成员对象可以正确初始化 可以在构造函数中使用初始化列表，其参数可以是复杂表达式，包含有定义的变量或函数
* 构造函数按成员对象在类中说明的次序调用，最后调用封闭类的构造函数，析构函数的调用次序则反过来
* 封闭类里默认的构造函数/复制构造函数初始化成员对象时，都会调用该对象的构造函数/复制构造函数。

### const
* 标const关键字的成员函数不能修改成员变量，不能调用非const的成员函数，当然了，因为static的并不算时某个具体对象的，所以可以
* 常量对象可以调用const成员函数
* 如果两个函数 参数表和名字之类的都相同，只差一个const，算是**重载**

### 友元
* 可以在类中把其它类的函数或其它类声明为friend，就可以不通过公有函数直接访问类的私有成员了
* 友元类之间的关系不能传递或继承


### 运算符重载
* 实质：函数重载
* 重载为成员函数时，参数个数为运算符目数减一
* 重载为普通函数时，参数个数为运算符目数 (可以加上friend访问私有成员)
* 返回值为临时对象
* **赋值运算符只能重载为成员函数** 注意区分赋值语句和初始化语句
* 浅拷贝和深拷贝 不对=进行重载、不自己写复制构造函数都会造成浅拷贝，即为指针的成员变量指向的是同一片内存空间
* 返回值一般为类的引用，这样才可以连等

### 可变长整形数组
* 构造函数 复制构造函数 析构函数 重载= length() push_back()等
* 变量：int size表示大小，int *ptr标识存储数组的开始地址

* 重载cout的时候因为不能修改自带的类，只能重载为普通函数： (friend) ostream & operator<<(ostream &o, 比如说某个类){blahblah; return o; } o就是cout

### 继承和复合 -- 重用性up
* 内存空间中，属于基类的在派生类新增成员的前面
* 派生类不能访问基类的private成员，但初始化列表可以初始化基类的private变量
* protected比private多的就是可以被派生类访问
* **c++的指针都是4个字节！**++（就这么规定的，别问为什么）++
* 类之间的“知道”关系：一个类中存的是另一个类的指针或指针数组 （eg. 主人和狗）
* 覆盖：在派生类中重写基类的成员变量或函数，但一般不定义重复的变量
* 构造函数是基类的先执行，派生的后执行

public继承情况下允许：
* 基类对象 = 派生类对象
* 基类 & = 派生类对象
* 基类 * = & 派生类对象

### 虚函数和多态 --面向对象比基于对象多的部分 --可扩充性up ***[基类指针->virtual函数]***
* virtual关键字只用在声明函数时写
* 构造函数和static成员函数不能virtual
* 提高可扩充性
* 虚函数的意思就是，它会自己判断实际的参数是基类还是派生类
* 可以用基类的指针数组存指向各种派生类对象的指针，这样的话遍历该数组就可以对这些对象进行操作，比如比大小
* 构造函数和析构函数中调用虚函数没有多态
* 动态联编：编译时不知道，运行时才知道

### string类
* typedef basic_string<char> string;
* 不能用字符初始化 string s = 'c' 错！但是赋值就可以：string s; s = 'c';
* 正确的初始化：string s1("hello"); string s2 = "world"; string s3(8,x);//8个x
* length(); cin>>s; getline(cin,s);
* string s1("hello"),s2;
* s2.assign(s1,1,3);// 从s1下标为1的字符开始复制3个字符
* s[3] = 'a'; cout<<s.at(2); at()会做范围检查，但下标运算不做，可能会越界！
* s1+=s2; s1.append(s2); s1.append(s2,3,5);//加入s2从下标3开始的5个字符、
* ==，>等符号都可以使用
* s1.compare(1,2,s2,0,3) // 把s1的1-2和s2的0-3比较 compare的两个一样时返回0，不一致的按字典序大小返回1或-1
* string s1 = "hello world",s2; s2 = s1.substr(4,5); //s2 = "o wor"
* s1.swap(s2); 
* s1.find("lo"); // 从头开找。rfind()则从后往前找。还可以find("a",5)从第5位开始往后找。
